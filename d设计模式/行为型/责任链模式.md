

# 责任链模式

> **定义：** 为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
>
> **结构：**
>
> > **抽象处理者角色：** 定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
> >
> > **具体处理者角色：** 实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转它的后继者。
> >
> > **客户类角色：** 创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。
>
> **优缺点：**
>
> > **优点：**
> >
> > 1. 降低了对象之间的耦合度，该模式降低了请求发送者和接收者的耦合度。
> >
> > 2. 增强了系统的可扩展性，可以根据需要增加新的请求处理类，满足开闭原则。
> >
> > 4. 责任链简化了对象之间的连接，一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if或者 if···else语句。
> >
> > 5. 责任分担，每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，
> >
> >    符合类的单一职责原则。
> >
> > **缺点：**
> >
> > 1. 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理。
> >
> > 2. 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
> >
> > 3. 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而
> >
> >    导致系统出错，如可能会造成循环调用。
> 
> **适用场景：**
>
> > 1. 在不明确指定请求处理者的情况下，向多个处理中的一个提交请求。
>> 2. 多个对象可以处理一个请求，但具体由哪个对象处理该请求在运行时自动确定。
> 
>**应用案例：**
> 
>> 在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。